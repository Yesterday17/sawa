---
globs: crates/core/**/*.rs
alwaysApply: false
---

# Sawa Domain Model - Project Specific

## Project Overview

Sawa is a collectible/merchandise inventory management system.

**Core Purpose:** Track user ownership of physical collectibles purchased from external suppliers, including mystery boxes (blind boxes) and regular items.

**Key characteristic:** This is a **record-keeping system** - users manually input their purchases, system tracks ownership and transfers.

## Aggregate Roots in This Project

**Independent Aggregates:**

- `Product` - Product catalog (does NOT contain variants)
- `ProductVariant` - Product SKU (independent from Product)
- `ProductInstance` - Individual owned items
- `PurchaseOrder` - Purchase records (embeds OrderItems)
- `User` - User accounts
- `Media` - Media files
- `UserTransaction` - User-to-user transfers

**Why Product and ProductVariant are separate:**

- Variants are modified frequently and independently
- Loading entire Product just to update one variant is inefficient
- Enables concurrent updates
- Better performance

## Domain Concepts

**Product:**

- Catalog-level information only
- Has name, description, media
- Does NOT contain variants

**ProductVariant:**

- Specific SKU/specification
- Can be regular item or mystery box
- Independent aggregate root

**ProductInstance:**

- ONE physical item owned by a user
- Tracks transfers and status changes
- `NotFound` = user physically lost the item

**PurchaseOrder:**

- Record of purchase from external supplier (NOT a shopping cart)
- Has creator and receiver (may differ for group buys)
- Embeds OrderedItems

**OrderedItem:**

- Sub-entity within PurchaseOrderItem
- Uses `seq: u32` for identification (not UUID)
- Tracks variant → instance creation
- Has transfer_transaction_id for auto-created transfers

## Status Enums in This Project

```rust
// PurchaseOrderStatus
Incomplete → Completed
          ↘ Cancelled

// PurchaseOrderItemStatus
AwaitingInput → Pending → Fulfilled
             ↘ Cancelled

// ProductInstanceStatus
Active, Locked, Consumed, NotFound, Destroyed

// TransactionStatus
Pending → Completed
       ↘ Cancelled
```

## Mystery Box Logic

- User MANUALLY fills in what they received (not system random)
- Snapshot mystery_box config in PurchaseOrderItem
- No duplicate checking (user records reality)
- Be lenient on validation (allow bonuses/errors)

## System Flow

```
External Supplier (infinite inventory)
    ↓ User purchases
PurchaseOrder created (record)
    ↓ User fills mystery box results
OrderedItem specs ready
    ↓ System fulfillment
ProductInstances created
    ↓ Auto-create UserTransactions (if needed)
Ownership transfers
```

## Transaction Flow

**Purchase Order Fulfillment:**

1. User creates order
2. Mystery boxes: user fills results → Pending
3. Regular items: automatically Pending
4. When ALL items Pending: can fulfill
5. Creates ProductInstances
6. Auto-creates UserTransactions if target_owner ≠ receiver

**User-to-User Transfer:**

1. Create UserTransaction
2. Lock ProductInstances (status = Locked)
3. Complete: transfer ownership, unlock
4. Cancel: unlock instances

## File Organization

```
crates/
  core/                      - Domain layer (PORTS)
    models/                  - Domain models
    repositories/            - Repository traits
    services.rs              - Manages services/
    services/
      purchase_order.rs      - Manages purchase_order/
      purchase_order/
        trait_def.rs         - PurchaseOrderService trait
        requests.rs          - Request types
        errors.rs            - Error types
      order_fulfillment.rs   - Manages order_fulfillment/
      order_fulfillment/
        trait_def.rs
        requests.rs
        errors.rs

  application/               - Application layer (ADAPTERS)
    services.rs              - Unified Service struct
    services/
      purchase_order_impl.rs
      order_fulfillment_impl.rs

  infra-memory/              - Infrastructure (ADAPTERS)
    repositories.rs          - In-memory implementations
```

## File Naming Conventions

### Service Organization

Each service is organized in its own directory with separated concerns:

```
services/
  purchase_order.rs          # Manages purchase_order/ directory
  purchase_order/
    trait_def.rs             # Service trait definition
    requests.rs              # Request types
    errors.rs                # Error types
    responses.rs             # Response types (if needed)
```

**Naming rules:**

- Service trait files: `trait_def.rs`
- Service trait names: MUST end with `Service`

  - Good: `PurchaseOrderService`, `OrderFulfillmentService`
  - Bad: `OrderManagement`, `CollectionQuery`

- Implementation files in application layer: use `_impl` suffix
  - Good: `purchase_order_impl.rs`
  - Bad: `purchase_order_service_impl.rs`

**Benefits:**

- Clear separation of concerns (trait, requests, errors)
- All related code in one directory
- Easy to navigate and maintain
- Errors defined alongside their service (high cohesion)

### Module Management

- **Do NOT use `mod.rs`** for managing submodules
- Use a file with the same name as the directory

Good: `services.rs` manages `services/` directory
Bad: `services/mod.rs`

## Error Handling

**Service Errors:**

- Use specific error types for each service operation (FulfillOrderError, CreateOrderError, etc.)
- Each error variant should include relevant context (IDs, reasons)
- Service errors are defined alongside their service traits in `errors.rs`
- Include PermissionDenied with user_id for authorization failures

**Repository Errors:**

- Use a single generic `RepositoryError` for all repositories
- Includes business-relevant variants:
  - `Duplicated { field, value }` - unique constraint violations
  - `HasDependencies { details }` - foreign key constraints
  - `Internal(String)` - infrastructure failures
- Service layer can match on variants to provide specific errors

**Example:**

```rust
// Service error includes Repository variant
#[derive(Debug, thiserror::Error)]
pub enum CreateUserError {
    #[error("User not found")]
    UserNotFound,

    #[error("Email already exists")]
    EmailExists,

    #[error("Repository error: {0}")]
    Repository(#[from] RepositoryError),
}

// Service handles Duplicated specially
match user_repo.save(&user).await {
    Err(RepositoryError::Duplicated { field, .. }) if field == "email" => {
        Err(CreateUserError::EmailExists)
    }
    Err(e) => Err(CreateUserError::Repository(e)),
    Ok(()) => Ok(user),
}
```

## Project-Specific Rules

- Product and ProductVariant are separate aggregates
- PurchaseOrder embeds PurchaseOrderItem (not IDs)
- OrderedItem uses seq: u32 (not UUID)
- Snapshot price and mystery_box config in orders
- History arrays don't store from_status

## Naming Consistency

When naming fields in Request/Response types, use complete snake_case names
that match the domain model:

- Good: `order_item_id` for `PurchaseOrderItemId`
- Bad: `item_id` (ambiguous - which kind of item?)

- Good: `variant_id` for `ProductVariantId`
- Good: `instance_id` for `ProductInstanceId`

Only use shortened names if they are unambiguous in context.
