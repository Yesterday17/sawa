---
globs: "**/*.rs"
alwaysApply: true
---

# General Coding Standards - Always Apply

## Language & Comments

- **All code comments MUST be in English**
- If you find non-English comments or awkward English, fix them immediately
- Respond to user in Chinese, but write code/comments/docs in English

## Type System & NewType Pattern

### ⚠️ CRITICAL: ALWAYS Use NewType for Domain Concepts

**Golden Rule:** If it has domain meaning, wrap it in a newtype. When in doubt, create a newtype.

**Mandatory NewTypes:**

```rust
// ✅ ALL Entity IDs - ALWAYS newtype with UUID
pub struct ProductId(pub NonNilUuid);
pub struct UserId(pub NonNilUuid);

// ✅ Domain primitives - ALWAYS newtype
pub struct NonEmptyString(String);  // Strings that cannot be empty
pub struct Email(String);           // Email addresses
pub struct Username(String);        // Usernames

// ✅ Quantities - ALWAYS use NonZeroU32 (never raw u32)
pub quantity: NonZeroU32  // NOT u32
pub count: NonZeroU32     // NOT u32
```

**Standard derives for newtypes:**

```rust
// For ALL ID types (mandatory)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SomeId(pub NonNilUuid);

impl SomeId {
    pub fn new() -> Self {
        Self(NonNilUuid::new(Uuid::now_v7()).expect("UUID v7 should never be nil"))
    }
}
```

**When to create NewTypes:**

- ✅ ALL entity IDs (no exceptions!)
- ✅ ALL domain concepts (Email, Username, etc.)
- ✅ Quantities with constraints (use NonZeroU32)
- ✅ Values with validation rules (NonEmptyString)
- ✅ Foreign keys

**Benefits:**

- Type safety: cannot mix ProductId with UserId
- Self-documenting code
- Compiler-enforced validation
- Domain meaning is explicit

## Derives

**Standard derives for types:**

```rust
// Enums (include PartialEq/Eq for filtering and comparisons)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Status { }

// ID types (Copy + Hash + PartialEq/Eq for HashMap keys)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SomeId(pub NonNilUuid);

// Value objects without String (Copy, usually no PartialEq/Eq)
#[derive(Debug, Clone, Copy)]
pub struct Price { }

// Value objects with String (Clone only)
#[derive(Debug, Clone)]
pub struct Address { }

// Entities (Clone for repository operations)
#[derive(Debug, Clone)]
pub struct SomeEntity { }
```

**Derives rationale:**

- **Enums:** Include PartialEq/Eq for filtering (`filter(|x| x.status == Status::Active)`)
- **Value objects:** Usually don't need PartialEq/Eq (not compared in business logic)
- **Entities:** Need Clone for in-memory repositories, no PartialEq/Eq (entities compared by ID)
- **IDs:** Need PartialEq/Eq/Hash for use in HashMap/HashSet

**Enum comparison:**

```rust
// ✅ Good - direct comparison
if item.status == Status::Pending { /* ... */ }

// ✅ Also good - pattern matching
match item.status {
    Status::Pending => { /* ... */ }
    _ => { /* ... */ }
}

// ✅ Also good - matches! macro for complex patterns
if matches!(item.status, Status::Pending | Status::Processing) { /* ... */ }
```

## Documentation Guidelines

### Code Comments Only

- **DO NOT** create separate Markdown documentation files (README.md, GUIDE.md, etc.)
- **DO** write comprehensive inline documentation using Rust doc comments
- All necessary documentation should live within the code itself

### Comments Style

```rust
/// Public API documentation (triple slash)
///
/// Explain what, why, and important invariants.
pub struct Something { }

// Internal implementation notes (double slash)
// Explain tricky logic or non-obvious decisions
fn internal_helper() { }
```

Always document:

- Why a design decision was made
- Invariants that must be maintained
- Complex business logic
- Usage examples for complex APIs

## Error Handling

Use fine-grained, operation-specific error types:

```rust
// ✅ Good - specific error for each operation
#[derive(Debug, thiserror::Error)]
pub enum FulfillOrderError {
    #[error("Order not found")]
    OrderNotFound,

    #[error("Permission denied: user {user_id:?} cannot fulfill this order")]
    PermissionDenied { user_id: UserId },

    // ... other specific errors
}

// ❌ Bad - generic error
#[derive(Debug, thiserror::Error)]
pub enum DomainError {
    #[error("Something went wrong")]
    GenericError,
}
```

**Principles:**

- Each service operation has its own error type
- Error variants should be specific and actionable
- Include context in error messages (IDs, reasons, etc.)

## Naming Conventions

### Fields

- `id` - Entity's own ID
- `xxx_id` - Reference to another entity (e.g., `product_id`, `user_id`)
- `xxx_at` - Timestamps (e.g., `created_at`, `completed_at`)
- `xxx_snapshot` - Historical snapshot

### Methods

- `new()` - Constructor
- `find_by_xxx()` - Repository queries
- `save()` - Repository write
- `set_xxx()` - Domain mutations

### Status Naming

Status should describe current state, not actions:

- Good: `Pending`, `Completed`, `Cancelled`
- Bad: `WaitingForPayment`, `HasBeenCompleted`

## Rust 2024 Edition Features

### Async Traits - Future in Prelude

In Rust 2024, `Future` trait is in the prelude, so you don't need to import it.

```rust
// ✅ Good - Future is in prelude
pub trait SomeRepository: Send + Sync + 'static {
    fn find(&self, id: &Id) -> impl Future<Output = Result<T>> + Send;
    fn save(&self, entity: &T) -> impl Future<Output = Result<()>> + Send;
}

// ❌ Bad - Don't import Future
use std::future::Future;  // Not needed in Rust 2024!

pub trait SomeRepository: Send + Sync + 'static {
    fn find(&self, id: &Id) -> impl Future<Output = Result<T>> + Send;
}
```

**Key Points:**

- `Future` is in the prelude in Rust 2024
- No need to import `std::future::Future`
- Cleaner, more ergonomic async trait definitions

## File Organization

### Module Management

- **Do NOT use `mod.rs` for managing submodules**
- Use a file with the same name as the directory instead

**Good structure:**

```
src/
  errors.rs           # Manages errors/ directory
  errors/
    services.rs       # Manages services/ subdirectory
    services/
      purchase_order.rs
```

**Bad structure:**

```
src/
  errors/
    mod.rs            # ❌ Don't use mod.rs
    services/
      mod.rs          # ❌ Don't use mod.rs
```

## Common Anti-Patterns

- ❌ Do NOT use raw u32 for quantities (use NonZeroU32)
- ❌ Do NOT use String directly for IDs (use newtype)
- ❌ Do NOT use parallel arrays (use cohesive structs)
- ❌ Do NOT add error variants until actually needed
- ❌ Do NOT use array indices for entity references (unstable)
- ❌ Do NOT import `std::future::Future` in Rust 2024 (not needed)
- ❌ Do NOT use `mod.rs` for submodule management
